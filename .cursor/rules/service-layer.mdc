# Service Layer Architecture Rules

## üîß **Core Principles**

### **Three-Layer Architecture**

1. **Endpoints**: API route definitions with TypeScript types
2. **Services**: Business logic and error handling
3. **Hooks**: React Query integration for components

### **Separation of Concerns**

- **Endpoints**: Define API contracts and types
- **Services**: Handle business logic, validation, and error handling
- **Hooks**: Provide React Query integration for components
- **Components**: Focus on UI and user interaction

## üåê **Endpoint Layer**

### **Endpoint Factory Pattern**

```typescript
// lib/services/api/endpoints.ts
export const endpoint = <TRequest = void, TResponse = any>(
  path: string,
  method: HTTPMethod
) => ({
  path,
  method,
  requestType: {} as TRequest,
  responseType: {} as TResponse,
})

// lib/services/api/auth-endpoints.ts
export const authEndpoints = {
  sendOtp: endpoint<SendOtpRequest, SendOtpResponse>('/auth/send-otp', 'POST'),
  verifyOtp: endpoint<VerifyOtpRequest, VerifyOtpResponse>(
    '/auth/verify-otp',
    'POST'
  ),
  logout: endpoint<void, LogoutResponse>('/auth/logout', 'POST'),
}
```

### **Type Safety in Endpoints**

```typescript
// ‚úÖ Correct - proper TypeScript types
export const userEndpoints = {
  getProfile: endpoint<void, UserProfile>('/user/profile', 'GET'),
  updateProfile: endpoint<UpdateProfileRequest, UserProfile>(
    '/user/profile',
    'PUT'
  ),
  deleteAccount: endpoint<DeleteAccountRequest, DeleteAccountResponse>(
    '/user/account',
    'DELETE'
  ),
}

// ‚ùå Incorrect - any types
export const userEndpoints = {
  getProfile: endpoint<any, any>('/user/profile', 'GET'),
}
```

## üöÄ **Service Layer**

### **Service Class Pattern**

```typescript
// lib/services/auth/auth-service.ts
export class AuthService {
  constructor(private apiClient: ApiClient) {}

  async sendOtp(
    mobileNumber: string,
    languageCode = 'en'
  ): Promise<SendOtpResponse> {
    try {
      const response = await this.apiClient.post(authEndpoints.sendOtp, {
        mobileNumber,
        languageCode,
      })

      return response.data
    } catch (error) {
      throw new AuthError('Failed to send OTP', { cause: error })
    }
  }

  async verifyOtp(otp: string): Promise<VerifyOtpResponse> {
    try {
      const response = await this.apiClient.post(authEndpoints.verifyOtp, {
        otp,
      })
      return response.data
    } catch (error) {
      throw new AuthError('Failed to verify OTP', { cause: error })
    }
  }

  async logout(): Promise<LogoutResponse> {
    try {
      const response = await this.apiClient.post(authEndpoints.logout)
      return response.data
    } catch (error) {
      throw new AuthError('Failed to logout', { cause: error })
    }
  }
}
```

### **API Client Pattern**

```typescript
// ‚úÖ Correct - use service layer
const result = await authService.sendOtp(mobileNumber)

// ‚ùå Incorrect - direct fetch
const response = await fetch('/api/auth/send-otp', {
  method: 'POST',
  body: JSON.stringify({ mobileNumber }),
})
```

### **Error Handling**

```typescript
// lib/services/base/error-factory.ts
export class AuthError extends Error {
  constructor(
    message: string,
    options?: {
      cause?: Error
      statusCode?: number
      code?: string
    }
  ) {
    super(message, options)
    this.name = 'AuthError'
  }
}

export class ValidationError extends Error {
  constructor(
    message: string,
    public field: string,
    options?: { cause?: Error }
  ) {
    super(message, options)
    this.name = 'ValidationError'
  }
}
```

## ü™ù **Hook Layer**

### **React Query Integration**

```typescript
// lib/services/hooks/auth-hooks.ts
export function useSendOtp() {
  const { setLoading, setOtpRequestId, setError } = useAuth()

  return useMutation({
    mutationFn: async ({ mobileNumber, languageCode = 'en' }) => {
      setLoading(true)
      setError(null)

      try {
        return await authService.sendOtp(mobileNumber, languageCode)
      } catch (error) {
        const message = 'Failed to send OTP. Please try again.'
        setError(message)
        throw error
      } finally {
        setLoading(false)
      }
    },
    onSuccess: data => {
      setOtpRequestId(data.requestId)
      setError(null)
    },
  })
}

export function useVerifyOtp() {
  const { setAuthData, setError, clearAuth } = useAuth()

  return useMutation({
    mutationFn: async ({ otp }: { otp: string }) => {
      return await authService.verifyOtp(otp)
    },
    onSuccess: data => {
      setAuthData({
        authKey: data.authKey,
        userId: data.userId,
      })
      setError(null)
    },
    onError: error => {
      setError('Failed to verify OTP. Please try again.')
    },
  })
}
```

### **Host-Consumer Pattern**

```typescript
// ‚úÖ Good - host-consumer pattern
export function useAuth() {
  const sendOtpMutation = useSendOtp()
  const verifyOtpMutation = useVerifyOtp()

  // Consolidated loading state
  const isLoading = sendOtpMutation.isPending || verifyOtpMutation.isPending

  return {
    sendOtp: sendOtpMutation.mutate,
    verifyOtp: verifyOtpMutation.mutate,
    isLoading, // Single loading state
  }
}
```

## üè¢ **Multi-Tenant Integration**

### **Tenant-Aware API Client**

```typescript
// lib/services/base/api-client.ts
export class ApiClient {
  constructor(private tenantId: string) {}

  async request<T>(config: ApiConfig): Promise<T> {
    const headers = {
      ...config.headers,
      'x-tenant-id': this.tenantId,
      'Content-Type': 'application/json',
    }

    // Add auth token if available
    const authToken = getAuthToken()
    if (authToken) {
      headers.Authorization = `Bearer ${authToken}`
    }

    return await this.httpClient.request({
      ...config,
      headers,
    })
  }

  async get<T>(url: string, config?: ApiConfig): Promise<T> {
    return this.request({ ...config, url, method: 'GET' })
  }

  async post<T>(url: string, data?: any, config?: ApiConfig): Promise<T> {
    return this.request({ ...config, url, method: 'POST', data })
  }

  async put<T>(url: string, data?: any, config?: ApiConfig): Promise<T> {
    return this.request({ ...config, url, method: 'PUT', data })
  }

  async delete<T>(url: string, config?: ApiConfig): Promise<T> {
    return this.request({ ...config, url, method: 'DELETE' })
  }
}
```

### **Service Factory**

```typescript
// lib/services/factory.ts
export function createTenantAwareService(tenantId: string) {
  const apiClient = new ApiClient(tenantId)

  return {
    authService: new AuthService(apiClient),
    userService: new UserService(apiClient),
    bookingService: new BookingService(apiClient),
  }
}
```

## üîÑ **Interceptors**

### **Request Interceptors**

```typescript
// lib/services/base/interceptors.ts
export class RequestInterceptor {
  onRequest(config: ApiConfig): ApiConfig {
    // Add tenant ID to all requests
    if (!config.headers) {
      config.headers = {}
    }

    config.headers['x-tenant-id'] = getCurrentTenantId()

    // Add auth token if available
    const authToken = getAuthToken()
    if (authToken) {
      config.headers.Authorization = `Bearer ${authToken}`
    }

    return config
  }
}
```

### **Response Interceptors**

```typescript
// lib/services/base/interceptors.ts
export class ResponseInterceptor {
  onResponse(response: ApiResponse): ApiResponse {
    // Handle successful responses
    return response
  }

  onError(error: ApiError): never {
    // Handle different error types
    if (error.status === 401) {
      // Handle unauthorized
      clearAuthToken()
      redirectToLogin()
    } else if (error.status === 403) {
      // Handle forbidden
      throw new ForbiddenError('Access denied')
    } else if (error.status >= 500) {
      // Handle server errors
      throw new ServerError('Server error occurred')
    }

    throw error
  }
}
```

## üß™ **Testing Patterns**

### **Service Testing**

```typescript
// __tests__/services/auth-service.test.ts
import { AuthService } from '@/lib/services/auth/auth-service'

describe('AuthService', () => {
  let authService: AuthService
  let mockApiClient: jest.Mocked<ApiClient>

  beforeEach(() => {
    mockApiClient = {
      post: jest.fn(),
    } as any

    authService = new AuthService(mockApiClient)
  })

  test('sendOtp calls correct endpoint', async () => {
    const mockResponse = { data: { requestId: 'test-request-id' } }
    mockApiClient.post.mockResolvedValue(mockResponse)

    const result = await authService.sendOtp('+1234567890')

    expect(mockApiClient.post).toHaveBeenCalledWith(authEndpoints.sendOtp, {
      mobileNumber: '+1234567890',
      languageCode: 'en',
    })
    expect(result).toEqual(mockResponse.data)
  })

  test('sendOtp throws AuthError on failure', async () => {
    const error = new Error('Network error')
    mockApiClient.post.mockRejectedValue(error)

    await expect(authService.sendOtp('+1234567890')).rejects.toThrow(AuthError)
  })
})
```

### **Hook Testing**

```typescript
// __tests__/hooks/auth-hooks.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { useSendOtp } from '@/lib/services/hooks/auth-hooks'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

describe('useSendOtp', () => {
  let queryClient: QueryClient

  beforeEach(() => {
    queryClient = new QueryClient({
      defaultOptions: {
        queries: { retry: false },
        mutations: { retry: false },
      },
    })
  })

  test('sends OTP successfully', async () => {
    const { result } = renderHook(() => useSendOtp(), {
      wrapper: ({ children }) => (
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      ),
    })

    result.current.mutate({ mobileNumber: '+1234567890' })

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true)
    })
  })
})
```

## üöÄ **Performance Optimization**

### **Caching Strategy**

```typescript
// lib/services/hooks/user-hooks.ts
export function useUserProfile() {
  return useQuery({
    queryKey: ['user', 'profile'],
    queryFn: () => userService.getProfile(),
    staleTime: 5 * 60 * 1000, // 5 minutes
    gcTime: 10 * 60 * 1000, // 10 minutes
  })
}
```

### **Optimistic Updates**

```typescript
// lib/services/hooks/user-hooks.ts
export function useUpdateProfile() {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: (data: UpdateProfileRequest) => userService.updateProfile(data),
    onMutate: async newProfile => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['user', 'profile'] })

      // Snapshot previous value
      const previousProfile = queryClient.getQueryData(['user', 'profile'])

      // Optimistically update
      queryClient.setQueryData(['user', 'profile'], newProfile)

      return { previousProfile }
    },
    onError: (err, newProfile, context) => {
      // Rollback on error
      queryClient.setQueryData(['user', 'profile'], context?.previousProfile)
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['user', 'profile'] })
    },
  })
}
```

## üéØ **Best Practices**

### **Do's**

- ‚úÖ **Always use service layer** for API calls
- ‚úÖ **Define proper TypeScript types** for requests and responses
- ‚úÖ **Implement comprehensive error handling** with custom error classes
- ‚úÖ **Use React Query** for server state management
- ‚úÖ **Implement proper caching strategies** with stale time and garbage collection
- ‚úÖ **Use optimistic updates** for better UX
- ‚úÖ **Test services and hooks** thoroughly

### **Don'ts**

- ‚ùå **Never use direct fetch** in components
- ‚ùå **Don't use any types** in endpoints
- ‚ùå **Avoid complex business logic** in hooks
- ‚ùå **Don't forget error handling** in services
- ‚ùå **Avoid manual cache management** - use React Query
- ‚ùå **Don't mix client and server state** in the same store

## üîÑ **Migration Patterns**

### **From Direct Fetch**

```typescript
// Before
const response = await fetch('/api/auth/send-otp', {
  method: 'POST',
  body: JSON.stringify({ mobileNumber }),
})

// After
const result = await authService.sendOtp(mobileNumber)
```

### **From Manual State Management**

```typescript
// Before
const [isLoading, setIsLoading] = useState(false)
const [error, setError] = useState(null)

const sendOtp = async mobileNumber => {
  setIsLoading(true)
  try {
    const response = await fetch('/api/auth/send-otp', {
      method: 'POST',
      body: JSON.stringify({ mobileNumber }),
    })
    // Handle response
  } catch (error) {
    setError(error.message)
  } finally {
    setIsLoading(false)
  }
}

// After
const { mutate: sendOtp, isPending: isLoading, error } = useSendOtp()
```

Follow these patterns consistently to maintain a robust, scalable service layer that provides excellent developer experience and user experience.
description:
globs:
alwaysApply: false

---
